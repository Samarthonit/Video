<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Run For Girl Child</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * {
      margin: 0; padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: #1f1f1f;
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
    }

    .container {
      width: 100%;
      max-width: 480px;
      text-align: center;
    }

    h1 {
      margin: 10px 0;
      font-size: 1.8rem;
      color: #ff6b6b;
    }

    .recorder-container {
      position: relative;
      width: 100%;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
      background-color: #000;
    }

    #frame {
      width: 100%;
      height: auto;
      display: block;
    }

    #webcam {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #canvas {
      display: none;
    }

    /* Webcam area positioned exactly like in the image */
    .webcam-area {
      position: absolute;
      top: 25%;
      left: 10%;
      width: 80%;
      height: 45%;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.5);
    }

    .webcam-feed {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
      flex-wrap: wrap;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 40px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-width: 130px;
    }

    .btn i {
      font-size: 1rem;
    }

    .btn-start { background: linear-gradient(45deg, #4CAF50, #45a049); color: white; }
    .btn-stop { background: linear-gradient(45deg, #f44336, #d32f2f); color: white; }
    .btn-download { background: linear-gradient(45deg, #2196F3, #1976d2); color: white; }
    .btn-share { background: linear-gradient(45deg, #9C27B0, #7b1fa2); color: white; }

    .btn:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .btn:active { transform: translateY(1px); }
    .btn:disabled { background: #555; cursor: not-allowed; transform: none; box-shadow: none; }

    .timer-container {
      margin: 15px 0;
      font-size: 1.4rem;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 30px;
    }

    .recording-indicator {
      display: inline-block;
      width: 14px;
      height: 14px;
      background-color: #f44336;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(0.9); opacity: 0.7; }
      50% { transform: scale(1.3); opacity: 1; }
      100% { transform: scale(0.9); opacity: 0.7; }
    }

    .status {
      margin: 15px 0;
      padding: 12px;
      border-radius: 10px;
      background: linear-gradient(45deg, rgba(255, 107, 107, 0.2), rgba(255, 193, 7, 0.2));
      font-size: 1rem;
      border-left: 4px solid #ff6b6b;
    }

    .download-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
      padding: 12px 18px;
      border-radius: 10px;
      display: none;
      animation: slideIn .3s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    /* Mobile optimization */
    @media (max-width: 600px) {
      body { padding: 8px; }
      h1 { font-size: 1.5rem; margin-bottom: 5px; }
      .webcam-area {
        top: 27%;
        left: 10%;
        width: 80%;
        height: 43%;
      }
      .btn { padding: 10px 18px; font-size: 0.9rem; min-width: 110px; }
      .timer-container { font-size: 1.2rem; }
    }
  </style>
</head>

<body>
  <div class="container">

    <div class="recorder-container">
      <!-- This is the frame image that contains all the design elements -->
      <img id="frame" src="frame.png" alt="Run For Girl Child Frame" />
      
      <!-- Webcam area positioned exactly where it should be in the frame -->
      <div class="webcam-area">
        <video id="webcam" class="webcam-feed" autoplay muted playsinline></video>
      </div>
      
      <!-- Hidden canvas for recording -->
      <canvas id="canvas"></canvas>
    </div>

    <div class="timer-container">
      <span id="timer">00:00:00</span>
      <div id="recordingIndicator" class="recording-indicator" style="display:none;"></div>
    </div>

    <div class="controls">
      <button id="startBtn" class="btn btn-start"><i class="fas fa-record-vinyl"></i>Start</button>
      <button id="stopBtn" class="btn btn-stop" disabled><i class="fas fa-stop"></i>Stop</button>
      <button id="downloadBtn" class="btn btn-download" disabled><i class="fas fa-download"></i>Download</button>
      <button id="shareBtn" class="btn btn-share" disabled><i class="fas fa-share-alt"></i>Share</button>
    </div>

    <div id="status" class="status">Click "Start" to begin recording</div>
  </div>

  <div id="downloadNotification" class="download-notification">
    <i class="fas fa-check-circle"></i> File downloaded successfully!
  </div>

  <script>
    const webcam = document.getElementById('webcam');
    const frame = document.getElementById('frame');
    const canvas = document.getElementById('canvas');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const shareBtn = document.getElementById('shareBtn');
    const timer = document.getElementById('timer');
    const recordingIndicator = document.getElementById('recordingIndicator');
    const status = document.getElementById('status');
    const downloadNotification = document.getElementById('downloadNotification');

    let mediaRecorder, recordedChunks = [], stream = null, recordingBlob = null, timerInterval;
    let seconds = 0, minutes = 0, hours = 0;

    // Function to check for MP4 support
    function getSupportedMimeType() {
      const types = [
        'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
        'video/mp4; codecs="avc1.428028, mp4a.40.2"',
        'video/webm; codecs="vp9,opus"',
        'video/webm; codecs="vp8,opus"',
        'video/webm'
      ];
      
      for (let type of types) {
        if (MediaRecorder.isTypeSupported(type)) {
          console.log('Using MIME type:', type);
          return type;
        }
      }
      return 'video/webm';
    }

    async function initWebcam() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 1280 },
            height: { ideal: 720 },
            facingMode: 'user'
          }, 
          audio: true 
        });
        webcam.srcObject = stream;
        
        // Wait for webcam to load
        await new Promise(resolve => {
          webcam.addEventListener('loadedmetadata', resolve);
        });
        
        // Set up canvas with proper dimensions
        setupCanvas();
        
        status.textContent = 'Webcam ready. Click "Start" to record.';
      } catch (err) {
        console.error('Error accessing webcam:', err);
        status.textContent = 'Error accessing webcam: ' + err.message;
        // Show fallback message
        status.innerHTML += '<br>Please allow camera access and refresh the page.';
      }
    }

    function setupCanvas() {
      const ctx = canvas.getContext('2d');
      
      // Set canvas to match the frame dimensions
      canvas.width = frame.offsetWidth;
      canvas.height = frame.offsetHeight;
      
      console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
      
      // Start the composite drawing
      requestAnimationFrame(drawComposite);
    }

    function drawComposite() {
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw the frame (background with all design elements)
      ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
      
      // Draw webcam in the exact same position as shown on webpage
      if (webcam.readyState >= 2) {
        const webcamArea = document.querySelector('.webcam-area');
        const rect = webcamArea.getBoundingClientRect();
        const containerRect = frame.getBoundingClientRect();
        
        // Calculate relative position within the frame
        const relativeX = (rect.left - containerRect.left) * (canvas.width / containerRect.width);
        const relativeY = (rect.top - containerRect.top) * (canvas.height / containerRect.height);
        const relativeWidth = rect.width * (canvas.width / containerRect.width);
        const relativeHeight = rect.height * (canvas.height / containerRect.height);
        
        // Draw webcam feed in the exact same position and size
        ctx.drawImage(webcam, relativeX, relativeY, relativeWidth, relativeHeight);
      }
      
      requestAnimationFrame(drawComposite);
    }

    function updateTimer() {
      seconds++;
      if (seconds >= 60) { seconds = 0; minutes++; if (minutes >= 60) { minutes = 0; hours++; } }
      timer.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function startRecording() {
      recordedChunks = [];
      
      // Capture from canvas (which shows exactly what we see on screen)
      const canvasStream = canvas.captureStream(30);
      const audioTrack = stream.getAudioTracks()[0];
      if (audioTrack) canvasStream.addTrack(audioTrack);
      
      // Get supported MIME type
      const mimeType = getSupportedMimeType();
      const isMp4 = mimeType.includes('mp4');
      
      mediaRecorder = new MediaRecorder(canvasStream, { 
        mimeType: mimeType,
        videoBitsPerSecond: 4000000 // Good quality bitrate
      });
      
      mediaRecorder.ondataavailable = e => { 
        if (e.data.size > 0) recordedChunks.push(e.data); 
      };
      
      mediaRecorder.onstop = () => {
        const blobType = isMp4 ? 'video/mp4' : 'video/webm';
        recordingBlob = new Blob(recordedChunks, { type: blobType });
        downloadBtn.disabled = false;
        shareBtn.disabled = false;
        status.textContent = `Recording complete (${isMp4 ? 'MP4' : 'WebM'}). You can download or share.`;
      };
      
      mediaRecorder.start(1000); // Collect data every second
      startBtn.disabled = true; 
      stopBtn.disabled = false;
      recordingIndicator.style.display = 'inline-block';
      timerInterval = setInterval(updateTimer, 1000);
      status.textContent = `Recording in progress (${isMp4 ? 'MP4' : 'WebM'})...`;
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        clearInterval(timerInterval);
        recordingIndicator.style.display = 'none';
        startBtn.disabled = false; 
        stopBtn.disabled = true;
        status.textContent = 'Recording stopped. Processing video...';
      }
    }

    function downloadRecording() {
      if (recordingBlob) {
        const isMp4 = recordingBlob.type.includes('mp4');
        const extension = isMp4 ? 'mp4' : 'webm';
        const url = URL.createObjectURL(recordingBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Run_For_Girl_Child_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.${extension}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showNotification();
      }
    }

    async function shareRecording() {
      if (!recordingBlob) return alert('No recording available to share!');
      
      const isMp4 = recordingBlob.type.includes('mp4');
      const extension = isMp4 ? 'mp4' : 'webm';
      const file = new File([recordingBlob], `Run_For_Girl_Child.${extension}`, { 
        type: recordingBlob.type 
      });
      
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            title: 'Run For Girl Child Recording',
            text: 'Check out my recording from Run For Girl Child event!',
            files: [file]
          });
          status.textContent = 'Recording shared successfully!';
        } catch (err) {
          console.log('Share cancelled or failed:', err);
          if (err.name !== 'AbortError') {
            status.textContent = 'Sharing failed. Try downloading instead.';
          }
        }
      } else {
        alert('Sharing not supported in your browser. Please download the video instead.');
      }
    }

    function showNotification() {
      downloadNotification.style.display = 'block';
      setTimeout(() => downloadNotification.style.display = 'none', 3000);
    }

    // Event listeners
    startBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);
    downloadBtn.addEventListener('click', downloadRecording);
    shareBtn.addEventListener('click', shareRecording);

    // Initialize when page loads
    window.addEventListener('load', initWebcam);

    // Handle page visibility changes (pause recording when tab not visible)
    document.addEventListener('visibilitychange', function() {
      if (document.hidden && mediaRecorder && mediaRecorder.state === 'recording') {
        status.textContent = 'Recording paused - tab not visible';
      }
    });
  </script>
</body>
</html>




